### Transaction(트랜잭션)이란?
> - 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야할 일련의 연산들을 의마한다.

#### Transaction의 특징
>
1. 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태변환 과정의 작업단위이다.
3. 하나의 트랜잭션은 Commit되거나 Rollbac 된다.

#### 트랜잭션의 성질 ACID
> #### Atomicity(원자성)
1. 트랜잭션의 연산은 데이터베이스에 모두 반영되던지 전혀 반영되지않아야한다.
2. 트랜잭션 내의 모든 명령은 반드시 완벽하게 수행되어야하고, 모두가 완벽히 수행되지않고 하나라도 오류가 생기면 트랜잭션 전부가 취소가 되고 실행되기 전 값으로 돌아온다.
#### Consistency(일관성)
1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. 시스템이 가지고 이쓴ㄴ 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야한다.
#### Isolation(독립성, 격리성)
1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션 연산이 끼어들 수 없다.
2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
#### Durability(영속성,지속성)
1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.


### Transaction 연산
**1. Commit**
- commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

**2. Rollback**
- Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리 되었더라도 트랜잭션의 일관성이 깨지기 때문에 원자성을 다시 구현하기 위해 트랜잭션에서 행한 모든 연산을 취소하는 연산이다.

### Transaction 상태
![](https://velog.velcdn.com/images/ihanseul731/post/8ec4663a-1831-4ce1-8158-ae0b281313ce/image.png)
- Active
트랜잭션의 활동 상태, 트랜잭션이 실행중인 상태

- Faild
트랜잭션 실패 상태, 정상적으로 진행할 수 없음

- Partially Commited
트랜잭션의 Commit명령이 도착한 상태. coomit이전 sql문이 수행되고 commit만 남은상태
오류가 나면 failed로 넘어가서 rollback

- Aborted
트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태

- Commit
Prtially Commited에서 문제없이 정상적으로 완료가 되었을때 Commit이 된 상태 
Prtially Commited랑 차이가 있음.

### Transaction 격리수준 
![](https://velog.velcdn.com/images/ihanseul731/post/68d50f5c-f259-450b-95fc-e1e8d1201f46/image.png)
> READUNCOMMITTED에 가까울수록 성능이 좋아지지만 데이터의 일관성은 떨어진다.
SERIALIZABLE에 가까울수록 성능이 떨어지고 데이터 일관성은 좋아짐
일반적인 온라인 서비스에서는 READ COMMITTED나 REPEATABLE READ 중 하나를 사용한다.
(oracle = READ COMMITTED, mysql = REPEATABLE READ)

#### READ UNCOMMITED
>READ UNCOMMITTED 격리수준에서는 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여진다.
이 격리수준에서는 아래와 같은 문제가 발생할 수 있다.
>1. A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꿈
>2. 아직 커밋하지 않음
>3. B 트랜잭션에서 10번 사원의 나이를 조회함
>4. 28살이 조회됨
>->이를 더티 리드(Dirty Read)라고 한다
>5. A 트랜잭션에서 문제가 발생해 ROLLBACK함
>6. B 트랜잭션은 10번 사원이 여전히 28살이라고 생각하고 로직을 수행함

#### READ COMMITED
>어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.
오라클 DBMS에서 기본으로 사용하고 있고, 온라인 서비스에서 가장 많이 선택되는 격리수준이다.
>1. B 트랜잭션에서 10번 사원의 나이를 조회
>2. 27살이 조회됨
>3. A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꾸고 커밋
>4. B 트랜잭션에서 10번 사원의 나이를 다시 조회(변경되지 않은 이름이 조회됨)
>5. 28살이 조회됨


#### REPETABLE READ
>트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.
MySQL DBMS에서 기본으로 사용하고 있고, 이 격리수준에서는 NON-REPETABLE READ 부정합이 발생하지 않는다.

### Transaction Lock
#### 잠금(Locking)이란?
>- 여러 사용자가 동일한 시간에 동일한 데이터를 엑세스할 수 있게 해준다.
- 잠금은 트랜잭션을 순차적으로 처리되도록 함으로써 손실된 업데이트를 방지하는데 중요한 역할을 하며 자동으로 발생한다.
- 잠금을 통해 데이터에 대한 일관성 유지와 동시사용 가능

#### 잠금모드
>1. 공유잠금
>- 트랜잭션이 데이터를 읽을 떄 공유 잠금을 걸게되며, 다른 트랜젝션도 **동일한 데이터에 대해 공유 잠금을 걸 수 있다.** 하지만 **동일한 데이터에 대한 단독 잠금을 걸 수는 없다.
>2. 단독잠금
>- 특랜잭션이 **데이터변경**을 할 때 단독으로 잠금을 걸게 된다.
단독 잠금이 걸리면 다른 트랜잭션이 공유 잠금을 걸 수 없으며 단독 잠금 또한 걸 수 없다.

#### 블록킹(Blocking)이란?
>- 어던 프로세스가 자원을 엑세스 하려고 할 때 이미 다른 프로세스가 그 자원을 잠그고 있어서 잠금된게 풀릴때 까지 기다려야하는 상황
>- **차단이 오래 유지될 경우 문제가 발생함**

#### 교착상태
>- 트랜잭션A는 트랜잭션 B가 원하는 데이터를 잠그고 있으면서 트랜잭션 B가 잠그고 있는 데이터를 원한다.
>- 트랜잭션B는 트랜잭션 A가 원하는 데이터를 잠그고 있으면서 트랜잭션 A가 잠그고 있는 데이터를 원한다.

**해결방법**
1. 한쪽 트랜잭션을 강제종료
2. 트랜잭션에 우선순위를 부여함
