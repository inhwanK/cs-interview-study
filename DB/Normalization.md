# 1. 정규화란?

한 릴레이션(table)에 여러 엔티티의 속성을 혼합하면 정보가 중복 저장되며 저장 공간을 낭비하게 됩니다.

</br>

이러한 **중복 정보는 릴레이션에 ‘이상 현상’을 유발하는 원인**이 되며, **이상 현상이 나타난 릴레이션을 분해하여 이상현상을 없애는 과정**을 정규화라고 합니다.

즉, 정규화란 데이터 베이스를 좋은 설계로 만들기 위해 조금씩 개선해 나가는 과정입니다.

</br>

그렇다면 좋은 데이터 베이스 설계란 뭘까요? 어떤 설계를 좋은 설계라고 할 수 있을까요?

</br>

그것을 알려면 디비에서 발생하는 **이상현상과 함수적 종속성에 대해 알아합니다.**

</br>

# 2. 이상 현상 (Anomaly)

이상 현상이란, **테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상**입니다.

</br>

이상 현상은 데이터를 삽입, 삭제, 갱신할 때 발생하게 되고, 이들을 각각 **삽입 이상, 삭제 이상, 갱신 이상이라 칭합니다.**

- 삽입 이상 (Insertion anomaly) : **데이터 삽입을 위해 원하지 않는 데이터까지 같이 삽입** 해야 하는 문제
- 삭제 이상(Deletion anomaly) : **데이터 삭제 시 필요한 정보까지 같이 삭제되어 원치 않는 정보의 손실이 발생**하는 문제
- 갱신 이상 (Update anomaly) : 데이터 갱신 시 일부만 변경하여 데이터가 불일치하는 모순, 또는 중복되는 튜플(column)이 존재하게 되는 문제

| 학번 | 지도교수 | 학과 | 과목 번호 | 성적 |
| --- | --- | --- | --- | --- |
| 123 | P1 | 컴퓨터 | C-60 | A |
| 123 | P1 | 컴퓨터 | C-92 | A |
| 210 | P2 | 수학 | C-60 | B |
| 300 | P3 | 전기 | C-73 | C |
| 400 | P4 | 컴퓨터 | D-79 | A |

</br>

### 1. 삽입 이상

**강의를 수강하지 않은 학생을 추가할 때, 과목 번호와 성적에 null값이 들어가거나 불필요한 데이터를 추가해야 삽입할 수 있는 문제**점이 발생합니다.

</br>

| 학번 | 지도교수 | 학과 |
| --- | --- | --- |
| 500 | P5 | 컴퓨터 |

학생이 수강신청을 할 때 반드시 과목 번호를 알아야 삽입이 가능합니다.

</br>

### 2. 삭제 이상

만약, **학번이 300인 학생이 과목 수강을 취소하면 C-73인 강의에 대한 정보도 모두 삭제**됩니다.

</br>

| 학번 | 지도교수 | 학과 | 과목 번호 | 성적 |
| --- | --- | --- | --- | --- |
| 123 | P1 | 컴퓨터 | C-60 | A |
| 123 | P1 | 컴퓨터 | C-92 | A |
| 210 | P2 | 수학 | C-60 | B |
| 300 | P3 | 전기 | C-73 | C |
| 400 | P4 | 컴퓨터 | D-79 | A |

</br>

### 3. 갱신 이상

만약, **학번이 123인 학생의 지도교수가 P2로 변경되면, 모든 칼럼에서 학번이 123인 학생의 지도교수를 변경**시켜야 합니다.
그렇지 않으면 데이터의 모순이 발생하게 됩니다.

</br>

| 학번 | 지도교수 | 학과 | 과목 번호 | 성적 |
| --- | --- | --- | --- | --- |
| 123 | P1 → P2 | 컴퓨터 | C-60 | A |
| 123 | P1 → P2 | 컴퓨터 | C-92 | A |
| 210 | P2 | 수학 | C-60 | B |
| 300 | P3 | 전기 | C-73 | C |
| 400 | P4 | 컴퓨터 | D-79 | A |

</br>

위의 **이상 현상은 설계의 적신호** 입니다.

</br>

만약 이상 현상이 발생 한다면 그 릴레이션은 정규화를 통해 설계를 개선해야 한다는 의미가 됩니다. 하지만 이미 사용 중인 DB 설계를 중간에 바꾼다는 것은 적지 않은 비용이 발생하는 일입니다.

</br>

때문에 우리는 어떠한 기준을 통해 지금의 설계가 좋은 설계인지, 나쁜 설계인지, 이상 현상이 발생할 가능성이 있어 개선해야 하는 설계인지 판단해야 합니다.

</br>

이러한 **설계의 개선의 기준을 함수 종속성** 이라고 합니다.

</br>

# 3. 함수 종속성

함수 종속성(Functional Dependency)은 어떤 테이블의 속성 A와 B에 대하여, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, “B는 A에 함수 종속이다”라고 할 수 있습니다. 기호로는 A → B로 나타냅니다.

</br>

**A → B의 관계**에서 **A를 결정자(Determinant)**, **B를 종속자(Dependant)**라고 합니다.

</br>

함수 종속성은 크게 완전 함수 종속, 부분 함수 종속, 이행적 함수 종속으로 다시 나뉩니다.

- 완전 함수 종속 : **기본키가 종속자가 되며, 종속자를 구성하는 모든 속성에 종속**되는 경우, **정규화의 대상이 아님**
- 부분 함수 종속 : **기본키를 구성하는 속성의 일부에 종속**되거나, **기본키가 아닌 다른 속성에 종속되는 경우**, **2차 정규화의 대상**
- 이행적 함수 종속성 : A, B, C 세 속성이 있고, **A → B, B → C 종속 관계가 있을 때, A → C가 성립하는 경우**, **3차 정규화의 대상**

| 학번(PK) | 이름 | 학년 | 과목번호(PK) | 과목 | 성적 |
| --- | --- | --- | --- | --- | --- |
|  |  |  |  |  |  |

위와 같은 테이블이 있을 때, 여러 학생들이 있고 각 학생별로 여러 과목을 수강한다고 할 때, 위 테이블의 기본키는 (학번, 과목번호)가 될것입니다.

</br>

그렇다면, 이름과 학년은 학번만 알아도 유일하게 결정됩니다. 반면에 성적은 학번과 과목 번호를 모두 알아야 유일하게 결정됩니다.

![함수 종속성](https://user-images.githubusercontent.com/90227655/198262794-48415680-3386-4005-b9da-4bdaedc2716b.PNG)

그러므로, 학년과 이름은 (학번, 과목번호)에 대해 부분 함수 종속이고, 성적은 완전 함수 종속입니다.

</br>

# 4. 정규화

**이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정**입니다. ****

정규화는 테이블이 어떻게 분해되는지에 따라 정규화 단계가 달라지는데 **제1 정규화, 제2 정규화, 제3 정규화, BCNF 정규화, 제4 정규화, 제5 정규화가있습니다.**

</br>

### 제 1 정규화

제 1 정규화는 다음과 같은 규칙들을 만족해야 합니다.

> 1. 각 칼럼이 하나의 속성만을 가져야 한다.
> 
> 2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
> 
> 3. 각 칼럼이 유일한(unique) 이름을 가져야 한다.
> 
> 4. 칼럼의 순서가 상관없어야 한다.

</br>

![제 1정규형 before](https://user-images.githubusercontent.com/90227655/198262838-d59ced87-3907-47a0-a2eb-7b8acf616ef4.png)

1. 각 컬럼이 하나의 값 만을 가져야 한다 → **X** **학생번호 101, 103의 과목컬럼이 두 개의 값을 가짐**
2. 하나의 컬럼은 같은 종류나 타입(Type)의 값을 가져야 한다. → O
3. 각 컬럼이 유일한(unique) 이름을 가져야 한다. → O
4. 칼럼의 순서가 상관없어야 한다. → O

</br>

아래와 같이 변경할 수 있습니다.

![제 1정규형 after](https://user-images.githubusercontent.com/90227655/198262860-c71e980c-fb11-423a-805f-b1b250e4bf2b.png)

</br>

### 제 2 정규화

제 2정규형은 다음과 같은 규칙이 존재합니다.

> 1. 1정규형을 만족해야 한다.
> 
> 2. 모든 컬럼에 부분적 함수 종속이 없어야 한다.

</br>

![제 2정규형 before](https://user-images.githubusercontent.com/90227655/198262888-f4525ca8-2ca7-46df-8769-9f5e08299163.png)

위와 같은 테이블의 기본키가 {학생번호, 과목}라는 복합키로 지정되어 있다고 가정했을 때,

지도 교수 칼럼은 {학생번호, 과목}에 종속되지 않고, {과목}에만 종속되는 부분적 함수 종속입니다.

</br>

따라서 아래와 같이 테이블을 개선 할 수 있습니다.

![제 2정규형 after](https://user-images.githubusercontent.com/90227655/198262924-e2819236-31cc-47b0-87bd-11b4188387cc.png)

</br>

### 제 3 정규화

제 3정규화는 다음과 같은 규칙을 만족해야합니다.

> 1. 2정규형을 만족해야 한다.
> 2. 기본키를 제외한 속성들간**의 **이행적 함수 종속성이 없어야 한다.

</br>

![제 3정규형before](https://user-images.githubusercontent.com/90227655/198263017-c51b83f5-d214-493d-b659-9a53295cf582.png)

위 예시를 보겠습니다. 위 예시에서는 ID를 알면 등급을 알 수 있습니다.

</br>

또한 할인율은 등급에 따라 달라집니다. 즉, 등급을 알아야 할인율을 알 수 있습니다.
때문에 ID를 알면 할인율을 알 수 있습니다.

</br>

이러한 상황에서 아래와 같이 개선할 수 있습니다.

![제 3정규형after](https://user-images.githubusercontent.com/90227655/198262958-81cb927b-1e9e-4242-93d4-a6dfa6bb2f4a.png)

</br>

### BCNF (Boyce-Code Normal Form)

BCNF는 제 3정규형을 좀 더 강화한 버전으로 다음과 같은 규칙을 만족해야 합니다.

> 1.3정규형을 만족해야 한다.
> 2. 모든 결정자가 후보키 집합에 속해야 한다.

</br>

즉, 후보키 집합에 없는 컬럼이 결정자가 되어서는 안된다는 것이죠.

![BCNF before](https://user-images.githubusercontent.com/90227655/198263044-bfd3dc07-710c-4c9d-9f2f-c557fd67d2e1.png)

위와 같은 테이블이 있다고 가정해 보겠습니다.

</br>

1. (학생번호, 과목)라는 기본키를 가지고 지도교수를 알 수 있습니다.  (학생번호, 과목) → 지도교수
2. 지도교수를 알면 지도 교수가 가르치는 과목을 특정할 수 있습니다. 지도교수 → 과목
3. 하지만 위 테이블에선 지도교수만을 가지고 특정한 튜플을 특정해 낼 수 없습니다. 즉, 지도교수는 후보키가 아닙니다.

위의 테이블 처럼 후보키 집합이 아닌 컬럼이 결정자가 되어버린 상황을 BCNF를 만족하지 않는다고 합니다.

</br>

BCNF 정규화는 아래와 같이 개선할 수 있습니다.

![BCNF after](https://user-images.githubusercontent.com/90227655/198263077-b2603098-1b60-47af-8e75-a42974e44b43.png)

</br>

### 정규화의 장점

- 이상 현상을 제거할 수 있다.
- 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향을 미치게 되어 응용프로그램의 생명을 연장시킨다.

</br>

### 정규화의 단점

- 릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산 증가 → 질의 응답 시간 저하

</br>

### 정규화 원칙

1. 정보의 무손실 : 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함해야 한다.
2. 최소 데이터 중복 : 이상 현상을 제거, 데이터 중복을 최소화
3. 분리의 원칙 : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리해서 표현

</br>

# 5. 반정규화

반정규화란 시스템의 성능 향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 의도적으로 정규화 원칙을 위배하는 것입니다.

</br>

반정규화 방법으로는 테이블 통합/테이블 추가/중복 속성 추가 등이 있습니다.

반정규화를 수행하면 테이블이 단순해지고 관리 효율성이 증가하지만, 데이터의 일관성이나 무결성이 보장되지 않을 수 있습니다. 의도적으로 중복 데이터를 생성하기 때문에 검색 기능은 향상되지만, 삽입/갱신/삭제 등의 성능은 낮아집니다.

</br>

반정규화를 고려해야할 상황은 다음과 같습니다.

1. 조회 수행 속도가 많이 느린 경우.
2. 테이블의 조인 연산을 지나치게 사용하여 데이터를 조회하는 것이 기술적으로 여려운 경우
3. 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우
